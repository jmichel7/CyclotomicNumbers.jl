var documenterSearchIndex = {"docs":
[{"location":"#CyclotomicNumbers","page":"Home","title":"CyclotomicNumbers","text":"","category":"section"},{"location":"#CyclotomicNumbers","page":"Home","title":"CyclotomicNumbers","text":"This  package deals with cyclotomic numbers,  the complex numbers which are linear  combinations  of  roots  of  unity,  usually  with with rational or integer  coefficients; but it is possible to use any coefficients <:Real. Cyclotomic numbers can be converted to Complex numbers.\n\nThe  cyclotomic  numbers  with  rational  coefficients  form  a  field, the cyclotomic  field. It  is the  maximal extension  of the  rationals with an abelian  Galois group. Its ring of  integers is the cyclotomic numbers with integer coefficients (called cyclotomic integers).\n\nCyclotomic  numbers are very  important for finite  groups, since character values of finite groups are cyclotomic integers.\n\nThis package depends only on the packages ModuleElt and Primes. It is a port  of the  GAP implementation  of cyclotomics,  which uses a normal form given  by writing them in the Zumbroich basis. This form allows to find the smallest  Cyclotomic field  which contains  a given  number, and  decide in particular  if a cyclotomic  is zero. Let  ζₙ=exp(2im*π/n). The Zumbroich basis is a particular subset of size φ(n) of 1,ζₙ,ζₙ²,…,ζₙⁿ⁻¹ which forms a basis of ℚ (ζₙ). The reference is\n\nT. Breuer, Integral bases for subfields of cyclotomic fields AAECC 8 (1997)\n\nI  started  this  file  by  porting  Christian  Stump's Sage code, which is simpler  to understand than GAP's C  code.\n\nAs GAP does, I lower automatically numbers after each computation, that is, reduce  them to the smallest cyclotomic  field where they belong. Currently the  code is somewhat  slower (depending on  the operation it  has the same speed or is slower up to 50%) than the C code in GAP but there are probably opportunities to optimize that I missed.\n\nWhat GAP does which I do not do is convert automatically a Cyclotomic which is  rational  to  a  Rational,  a  Rational  which  is  integral  to an Integer,  a  BigInt  which  is  small  to  an  Int,  etc…  This  is a tremendously  important optimization but because of type stability in Julia it  needs  a  new  type  of  number  to  be  added to Julia, which I am not competent enough to try.\n\nThis package is similar (and mostly compatible) with Marek Kaluba's package Cyclotomics,  whose existence I discovered after writing this package. We discussed merging them but concluded it would be a lot of work for benefits which are not clear currently. Some differences are:\n\nI define two types in this package: Root1 represents a root of unity, and Cyc a cyclotomic number. The advantage of having a separate type for roots of unity is that computations are very fast for them, of which I take advantage in the package CycPol for polynomials whose zeros are roots of unity.\nIn Kaluba's package  numbers are not  systematically lowered but only on demand  (like  for  printing).  this  speeds  up some computations by a factor  approaching 2, but it also makes some computations I have to do infeasible,  like the following one, which if not lowering involves too large fields; the answer is -36ζ₃²:\n\njulia> prod(x->1-x,[E(3),E(3,2),E(6),E(6,5),E(8),E(8),E(8,5),E(8,7),E(9,2),\nE(9,5),E(9,8),E(12,7),E(12,11),E(16),E(16,3),E(16,5),E(16,9),E(16,11),E(16,13),\nE(18,5),E(18,5),E(18,11),E(18,11),E(18,17),E(18,17),E(21,2),E(21,5),E(21,8),\nE(21,11),E(21,17),E(21,20),\nE(27,2),E(27,5),E(27,8),E(27,11),E(27,14),E(27,17),E(27,20),E(27,23),E(27,26),\nE(32,7),E(32,15),E(32,23),E(32,31),E(39),E(39,4),E(39,7),E(39,10),E(39,16),\nE(39,19),E(39,22),E(39,25),E(39,28),E(39,31),E(39,34),E(39,37),E(42),E(42,13),\nE(42,19),E(42,25),E(42,31),E(42,37),E(48,11),E(48,19),E(48,35),E(48,43),E(60,7),\nE(60,19),E(60,31),E(60,43),E(78,5),E(78,11),E(78,17),E(78,23),E(78,29),E(78,35),\nE(78,41),E(78,47),E(78,53),E(78,59),E(78,71),E(78,77),E(80,7),E(80,23),E(80,31),\nE(80,39),E(80,47),E(80,63),E(80,71),E(80,79),E(88,3),E(88,19),E(88,27),E(88,35),\nE(88,43),E(88,51),E(88,59),E(88,67),E(88,75),E(88,83),E(90),E(90,7),E(90,13),\nE(90,19),E(90,31),E(90,37),E(90,43),E(90,49),E(90,61),E(90,67),E(90,73),\nE(90,79),E(96,5),E(96,13),E(96,29),E(96,37),E(96,53),E(96,61),E(96,77),E(96,85),\nE(104),E(104,9),E(104,17),E(104,25),E(104,33),E(104,41),E(104,49),E(104,57),\nE(104,73),E(104,81),E(104,89),E(104,97),E(144),E(144,17),E(144,25),E(144,41),\nE(144,49),E(144,65),E(144,73),E(144,89),E(144,97),E(144,113),E(144,121),\nE(144,137),E(152,5),E(152,13),E(152,21),E(152,29),E(152,37),E(152,45),\nE(152,53),E(152,61),E(152,69),E(152,77),E(152,85),E(152,93),E(152,101),\nE(152,109),E(152,117),E(152,125),E(152,141),E(152,149),E(204,11),E(204,23),\nE(204,35),E(204,47),E(204,59),E(204,71),E(204,83),E(204,95),E(204,107),\nE(204,131),E(204,143),E(204,155),E(204,167),E(204,179),E(204,191),E(204,203)])\n\nIf you develop my package it is easy to use the strategy of lowering only on  demand or to use alternate implementations like dense vectors or sparse vectors (like Cyclotomics) –- I prepared boolean flags to choose various implementations  in the  code. I  have currently  chosen the implementation with ModuleElts and systematic lowering as giving the best results.\n\nThe  main  way  to  build  a  Cyclotomic  number  is  to  use  the function E(n,k=1)  which constructs the  Root1 equal to ζₙᵏ, and then make linear combinations of such numbers.\n\nExamples\n\njulia> E(3,2) # a root of unity\nRoot1: ζ₃²\n\njulia> E(3)+E(4) # nice display at the repl\nCyc{Int64}: ζ₁₂⁴-ζ₁₂⁷-ζ₁₂¹¹\n\njulia> print(E(3)+E(4)) # otherwise give output which can be parsed back\nE(12,4)-E(12,7)-E(12,11)\n\njulia> E(12,11)-E(12,7) # square roots of integers are recognized on output\nCyc{Int64}: √3\n\njulia> repr(E(12,11)-E(12,7),context=(:limit=>true,:quadratic=>false)) # but you can prevent that recognition\n\"-ζ₁₂⁷+ζ₁₂¹¹\"\n\njulia> a=E(3)+E(3,2)\nCyc{Int64}: -1\n\njulia> conductor(a) # a has been lowered to ℚ (ζ₁)=ℚ\n1\n\njulia> typeof(Int(a))\nInt64\n\njulia> Int(E(4))\nERROR: InexactError: convert(Int64, E(4))\n\njulia> inv(1+E(4))  # inverse by default is rational\nCyc{Rational{Int64}}: (1-ζ₄)/2\n\njulia> Cyc(1//2+im) # we can convert Gaussian rationals to cyclotomics\nCyc{Rational{Int64}}: (1+2ζ₄)/2\n\njulia> conj(1+E(4)) # complex conjugate\nCyc{Int64}: 1-ζ₄\n\njulia> real(E(3))  # real part\nCyc{Rational{Int64}}: -1//2\n\njulia> Rational{Int}(real(E(3)))\n-1//2\n\njulia> imag(E(3))  # imaginary part\nCyc{Rational{Int64}}: √3/2\n\njulia> c=Cyc(E(9))   # the normal form in the Zumbroich basis has two terms\nCyc{Int64}: -ζ₉⁴-ζ₉⁷\n\njulia> Root1(c) #  but you can convert back to Root1 if possible\nRoot1: ζ₉\n\njulia> Root1(1+E(4)) # the constructor Root1 returns nothing for a non-root\n\nThe  group of roots of  unity is isomorphic to  ℚ /ℤ , thus Root1 are represented internally by a rational number in [0,1[.\n\njulia> Root1(;r=1//4) # this constructor ensures the fraction is in [0,1[\nRoot1: ζ₄\n\njulia> c=E(4)*E(3) # fast computation if staying inside roots of unity\nRoot1: ζ₁₂⁷\n\nRoot1  have the same  operations as Cyc,  but are first converted  to Cyc for  any operation other  than one, isone,  *, ^, inv, conj, /, //. A Root1 can be raised to a Rational power, which extracts a root if needed. A Root1 can be taken apart using order and exponent –-  if a and b are  prime to each other, a  is the order of E(a,b) and  b (taken mod  a) is the  exponent. Note that  the order is not the conductor since E(6)==-E(3) has order 6 and conductor 3.\n\njulia> c=Complex{Float64}(E(3))  # convert to Complex{float} is sometimes useful\n-0.4999999999999999 + 0.8660254037844387im\n\nIn  presence  of  a  Cyc  a  number  <:Real  or  <:Complex{<:Real} is converted to a Cyc.\n\njulia> 0.0+E(3)\nCyc{Float64}: 1.0ζ₃\n\njulia> E(3)+1//2\nCyc{Rational{Int64}}: √-3/2\n\njulia> E(3)+im\nCyc{Int64}: ζ₁₂⁴-ζ₁₂⁷-ζ₁₂¹¹\n\nThe  function  complex  converts  a  Cyc{T}  to  a  Complex{T} if the conductor is 1 or 4, to a Complex{float(T)} otherwise.\n\njulia> complex(E(4))\n0 + 1im\n\njulia> complex(E(3))\n-0.4999999999999999 + 0.8660254037844387im\n\nCycs have methods copy, hash, ==, cmp, isless (total order) so they can be  keys in hashes, elements of sets,  and can be sorted. Cyclotomics which are  integers  or  rationals  compare  correctly  to Reals (this does not extend to irrational real Cycs):\n\njulia> -1<Cyc(0)<1\ntrue\n\nCycs have the operations +, -, *, /, //, inv, ^, conj, abs2, abs, image, real, reim, isinteger, isreal, one, isone, zero, iszero, complex, adjoint. Cyclotomics   with  rational  or  integer  coefficients  have  the  methods numerator  and  denominator:  a  Cyc  x  is a Cyclotomic integer if denominator(x)==1   and  then  numerator(x)   gives  the  corresponding Cyc{<:Integer}.\n\nYou  can pick apart a cyclotomic in various ways. The fastest is to use the iterator  pairs which, for a cyclotomic  a of conductor e iterates on the  pairs (i,c) such that  a has a non-zero  coefficient c on ζₑⁱ. You  can also get  the coefficient of  ζₑⁱ as a[i]  but it is slower to iterate  on coefficients  this way.  Finally you  can get (efficiently) the vector of all coefficients by coefficients.\n\njulia> a=E(3)+E(4)\nCyc{Int64}: ζ₁₂⁴-ζ₁₂⁷-ζ₁₂¹¹\n\njulia> collect(pairs(a))\n3-element Vector{Pair{Int64, Int64}}:\n  4 => 1\n  7 => -1\n 11 => -1\n\njulia> a[6],a[7]\n(0, -1)\n\njulia> coefficients(a)\n12-element Vector{Int64}:\n  0\n  0\n  0\n  0\n  1\n  0\n  0\n -1\n  0\n  0\n  0\n -1\n\njulia> valtype(a) # the type of the coefficients of a\nInt64\n\nFor more information see the methods Quadratic, galois, root, conjugates.\n\nFinally, a benchmark:\n\njulia> function testmat(p)\n         ss=[[i,j] for i in 0:p-1 for j in i+1:p-1]\n         [(E(p,i'*reverse(j))-E(p,i'*j))//p for i in ss,j in ss]\n       end\ntestmat (generic function with 1 method)\n\njulia> @btime CyclotomicNumbers.testmat(12)^2;  # on Julia 1.8.5\n  182.929 ms (2032503 allocations: 198.22 MiB)\n\nThe equivalent in GAP:\n\ntestmat:=function(p)local ss;ss:=Combinations([0..p-1],2);\n  return List(ss,i->List(ss,j->(E(p)^(i*Reversed(j))-E(p)^(i*j))/p));\nend;\n\ntestmat(12)^2 takes 0.31s in GAP3, 0.22s in GAP4\n\n\n\n\n\n","category":"module"},{"location":"#CyclotomicNumbers.E","page":"Home","title":"CyclotomicNumbers.E","text":"E(n,p=1)  returns the Root1  equal to ζₙᵖ (where  ζₙ is the root of unity whose approximate value is exp(2im*π/n))\n\n\n\n\n\n","category":"function"},{"location":"#CyclotomicNumbers.Root1","page":"Home","title":"CyclotomicNumbers.Root1","text":"Root1  is a type representing roots of unity. The internal representation is  by a Rational{Int} of the form  y//x where the integers y and x satisfy  0≤y<x, representing the  root of unity  ζₓʸ (where ζₓ is the root  of  unity  whose  approximate  value  is  exp(2im*π/x)).  Efficient constructors are Root1(;r=y//x) and E.\n\n\n\n\n\n","category":"type"},{"location":"#CyclotomicNumbers.Cyc","page":"Home","title":"CyclotomicNumbers.Cyc","text":"Cyc(c::Complex) converts c to a Cyc of conductor 4\n\n\n\n\n\nCyc(a::Root1) converts a to a Cyc\n\n\n\n\n\n","category":"type"},{"location":"#CyclotomicNumbers.conductor","page":"Home","title":"CyclotomicNumbers.conductor","text":"conductor(c::Cyc)\n\nreturns the smallest positive integer  n such that c∈ ℚ (ζₙ)\n\nconductor(a::AbstractArray)\n\nsmallest positive integer  n such that all elements of a are in ℚ (ζₙ)\n\njulia> conductor(E(6))\n3\n\njulia> conductor([E(3),1//2,E(4)])\n12\n\n\n\n\n\n","category":"function"},{"location":"#CyclotomicNumbers.coefficients","page":"Home","title":"CyclotomicNumbers.coefficients","text":"coefficients(c::Cyc)\n\nfor  a cyclotomic c of conductor n,  returns a vector v of length n such that c==∑ᵢ vᵢ₊₁ ζⁱ for i∈ 0:n-1.\n\njulia> coefficients(Cyc(E(9)))\n9-element Vector{Int64}:\n  0\n  0\n  0\n  0\n -1\n  0\n  0\n -1\n  0\n\n\n\n\n\n","category":"function"},{"location":"#Base.denominator","page":"Home","title":"Base.denominator","text":"denominator(c::Cyc{<:Rational})\n\nreturns   the   smallest   integer   d   such  that  d*c  has  integral coefficients (thus is an algebraic integer).\n\n\n\n\n\n","category":"function"},{"location":"#CyclotomicNumbers.galois","page":"Home","title":"CyclotomicNumbers.galois","text":"galois(c::Cyc,n::Integer)  applies  to  c  the  galois  automorphism  of ℚ (ζ_conductor(c))  raising  all  roots  of  unity  to the n-th power. n should be prime to conductor(c).\n\nExamples\n\njulia> galois(1+E(4),-1) # galois(c,-1) is the same as conj(c)\nCyc{Int64}: 1-ζ₄\n\njulia> galois(root(5),2)==-root(5)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#CyclotomicNumbers.conjugates","page":"Home","title":"CyclotomicNumbers.conjugates","text":"conjugates(c)\n\nreturns the list of distinct galois conjugates of c (over the Rationals), starting with c\n\njulia> conjugates(1+root(5))\n2-element Vector{Cyc{Int64}}:\n 1+√5\n 1-√5\n\n\n\n\n\n","category":"function"},{"location":"#CyclotomicNumbers.Quadratic","page":"Home","title":"CyclotomicNumbers.Quadratic","text":"Quadratic(c::Cyc)\n\ndetermines  if  c  lives  in  a  quadratic  extension  of  ℚ. The call q=Quadratic(c)  returns a  struct Quadratic  with fields  q.a, q.b, q.root,  q.den such that c==(q.a + q.b root(q.root))//q.den if such a representation is possible or returns nothing otherwise.\n\nExamples\n\njulia> Quadratic(E(3,2)-2E(3))\n(1-3√-3)/2\n\njulia> Quadratic(1+E(5))\n\n\n\n\n\n\n","category":"type"},{"location":"#CyclotomicNumbers.root","page":"Home","title":"CyclotomicNumbers.root","text":"root(x,n=2)\n\ncomputes  an n-th root of x  when we know how to  do it. We know how to compute  n-th roots  of roots  of unity,  and n-th  or 2n-th roots of perfect n-th powers of integers or rationals.\n\njulia> root(-1)\nCyc{Int64}: ζ₄\n\njulia> root(E(4))\nRoot1: ζ₈\n\njulia> root(27//8,6)\nCyc{Rational{Int64}}: √6/2\n\n\n\n\n\n","category":"function"},{"location":"#CyclotomicNumbers.Elist","page":"Home","title":"CyclotomicNumbers.Elist","text":"CyclotomicNumbers.Elist(n,i)\n\nexpresses  ζₙⁱ in  zumbroich_basis(n): it  is a  sum of some ζₙʲ with coefficients  all 1  or all  -1. The  result is  a Pair sgn=>inds where sgn is true if coefficients are all 1 and false otherwise, and inds is  the  list  of  i  in  0:n-1  such that ζₙⁱ occurs with a non-zero coefficient.\n\nShould only be called with i∈ 0:n-1\n\n\n\n\n\n","category":"function"},{"location":"#CyclotomicNumbers.zumbroich_basis","page":"Home","title":"CyclotomicNumbers.zumbroich_basis","text":"CyclotomicNumbers.zumbroich_basis(n::Int)\n\nreturns  the Zumbroich basis of ℚ (ζₙ) as the sorted vector of i in 0:n-1   such that ζₙⁱ is in the basis.\n\n\n\n\n\n","category":"function"},{"location":"#CyclotomicNumbers.prime_residues","page":"Home","title":"CyclotomicNumbers.prime_residues","text":"CyclotomicNumbers.prime_residues(n) the numbers less than n and prime to n \n\n\n\n\n\n","category":"function"},{"location":"#CyclotomicNumbers.modZ","page":"Home","title":"CyclotomicNumbers.modZ","text":"modZ(x::Rational{<:Integer}) returns x mod ℤ as a rational in [0,1[\n\n\n\n\n\n","category":"function"},{"location":"#Base.numerator-Union{Tuple{Cyc{<:Union{Rational{T}, T}}}, Tuple{T}} where T<:Integer","page":"Home","title":"Base.numerator","text":"numerator(c::Cyc{<:Rational})\n\nreturns denominator(c)*c as a cyclotomic over the integers.\n\n\n\n\n\n","category":"method"}]
}
